**JCF体系结构**

​										JCF

​				Collection								MAP

​		List					Set							HashMap

​	元素有序不唯一		元素无序唯一						SortedMap

​	ArrayList				HashSet

​	LinkedList				SortedSet					TreeMap

​	Vector					TreeMap

​	Stack						

**Collection与Collections的区别**

答：Collection是集合接口，它提供了对集合对象进行基本操作的通用接口方法。存在的意义是为各种具体集合提供最大化的统一操作方式。

​	Collections是包装类，包含各种集合有关的静态方法。此类不能实例化，服务于Collection接口。

**ArrayList & LinkedList 区别**

答：ArrayList底层数组实现，连续存储。查找遍历随机获取效率高。

​	LinkedList底层链表实现，添加删除效率高。

**ArrayList & Vector 区别**

答：ArrayList支持多线程同时操作，效率高，但可能出现并发错误，ArrayList在JDK1.6及之前扩容机制为 

​	x*3/2 +1 	1.7之后 x+x>>1   JDK1.2后出现

​	Vector不支持多线程同时操作，不会出现并发错误，效率较ArrayList低。Vector扩容实现本为 x*2     之后变					为List<>  list = new Vector<>(10,3); 10为默认空间，3为每次扩容添加的空间。 JDK1.0出现

**栈结构有什么特点**

答：先进后出，后进先出；

**HashSet如何保证元素唯一**

答：通过重写equals（）和hashCode（）方法；

**如何调整HashSet的性能和空间的取舍**

答：HashSet以及HashMap构造方法可以传递两个参数，第一个是分组组数，第二个是加载因子，两者乘起来表					示达到扩容条件的最小临界值，称为阈值，也就是当元素个数。达到阈值时，HashSet会考虑扩容，2倍扩容，得			到一个新的哈希表，再重新散列，效率很低。
所以我们需要避免扩容，也就是当我们知道元素总量的情况下，传入参数，使得 分组组数*加载因子 > 数据总量，在这个条件下，增大分组组数，效率提高，但浪费空间
增大加载因子，节省空间，但效率较低。所以实际中如果内存不够使，应当让增大加载因子，节省空间，对效率要求较高，则提高分组组数。

**简述CME出现的原因  如何避免CME**

答：在使用迭代器遍历集合的过程当中不允许对集合整体进行添加或者删除操作，否则迭代器的next()方法会触发并发修改异常 
*：虽然我们可以使用break来防止下一次next()触发异常，但是这样只能操作一个对象
如果一定要去执行删除操作，应该使用迭代器遍历，过程中应该使用迭代器自身的car.remove()；
如果一定要去执行添加，可以使用另一个集合暂存数据，待遍历完成之后再整体添加回原集合

**HashSet添加元素时，若被认定重复 会怎么办**

直接放弃添加，而不会替代原有元素，HashSet特性先入先得。